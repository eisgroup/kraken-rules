import { KelParser } from '../src/KelParser'

describe('KelParser', () => {
    it('should return readable syntax error with non existing operator', () => {
        const parser = new KelParser('1 + 1 is 2')
        parser.parseExpression()
        const errors = parser.getSyntaxErrors()
        expect(errors).toHaveLength(1)

        expect(errors[0].message).toContain("Invalid token 'is'")
        expect(errors[0].message).toContain('Expected')
        expect(errors[0].message).toContain("'='")
        expect(errors[0].message).not.toContain('EOF')
        expect(errors[0].message).not.toContain('OP')
        expect(errors[0].message).not.toContain('_')
    })
    it('should return readable syntax error with not finished expression', () => {
        const parser = new KelParser('{1,}')
        parser.parseExpression()
        const errors = parser.getSyntaxErrors()
        expect(errors).toHaveLength(1)
        expect(errors[0].message).toContain("Invalid token '}'")
        expect(errors[0].message).toContain('Expected')
        expect(errors[0].message).toContain("'-'")
        expect(errors[0].message).not.toContain('EOF')
        expect(errors[0].message).not.toContain('OP')
        expect(errors[0].message).not.toContain('_')
    })
    it('should return readable syntax error with not finished filter expression', () => {
        const parser = new KelParser('collection[]')
        parser.parseExpression()
        const errors = parser.getSyntaxErrors()
        expect(errors).toHaveLength(1)
        expect(errors[0].message).toContain("Invalid token '[]'")
        expect(errors[0].message).not.toContain('EOF')
        expect(errors[0].message).not.toContain('OP')
        expect(errors[0].message).not.toContain('_')
    })
    it('should return readable syntax error with not finished path expression', () => {
        const parser = new KelParser('1+1=2 and Policy.')
        parser.parseExpression()
        const errors = parser.getSyntaxErrors()
        expect(errors).toHaveLength(1)
        expect(errors[0].message).toBe('Syntax error occurred, please check the correctness of an expression')
        expect(errors[0].message).not.toContain('EOF')
        expect(errors[0].message).not.toContain('OP')
        expect(errors[0].message).not.toContain('_')
    })
    it('should return readable syntax error with not finished for return expression', () => {
        const parser = new KelParser('for v in Vehicle return')
        parser.parseExpression()
        const errors = parser.getSyntaxErrors()
        expect(errors).toHaveLength(1)
        expect(errors[0].message).toBe('Unexpected end of expression')
        expect(errors[0].message).not.toContain('EOF')
        expect(errors[0].message).not.toContain('OP')
        expect(errors[0].message).not.toContain('_')
    })
})
